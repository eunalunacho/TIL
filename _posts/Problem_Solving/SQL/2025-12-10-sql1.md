---
title: "[solvesql] Advent of SQL 2025 : 10일차"
date: 2025-12-10 14:24:00 +0900  
categories: [SQL]                
tags: [TIL, ORACLE, MYSQL, solvesql, 코딩테스트]       
permalink: /20251210_sql1/          
--- 

### 문제 링크

[문제 바로가기](https://solvesql.com/collections/advent-of-sql-2025/)



### 내 풀이
MYSQL
```sql
WITH
  volleyball AS (
    SELECT
      a.id,
      a.name,
      r.medal
    FROM
      records r
      JOIN athletes a ON r.athlete_id = a.id
      JOIN events e ON r.event_id = e.id
      JOIN games g ON r.game_id = g.id
      JOIN teams t ON r.team_id = t.id
    WHERE
      g.year <= 2016
      AND t.team = 'KOR'
      AND e.event = 'Volleyball Women''s Volleyball'
      AND medal IS NOT NULL
  )
SELECT
  id,
  name,
  GROUP_CONCAT(medal SEPARATOR ', ') AS medals
FROM
  volleyball
GROUP BY
  id
```



### 다른 풀이
MYSQL
```sql
SELECT
  a.id,
  a.name,
  GROUP_CONCAT(r.medal SEPARATOR ', ') AS medals
FROM
  records r
  -- 1. 가장 먼저 필터링 가능한 테이블들과 조인해 데이터 범위를 줄임 
  INNER JOIN games g ON r.game_id = g.id
  INNER JOIN teams t ON r.team_id = t.id
  INNER JOIN events e ON r.event_id = e.id
  -- 2. 마지막에 이름 정보를 위해 조인
  INNER JOIN athletes a ON r.athlete_id = a.id
WHERE
  r.medal IS NOT NULL               
  AND g.year <= 2016
  AND t.team = 'KOR'
  AND e.event = 'Volleyball Women''s Volleyball'
GROUP BY
  a.id
```
- Filter Early: WHERE 절에서 medal IS NOT NULL을 바로 적용하여, 불필요한 데이터를 메모리에 올리지 않음 
- Optimizer Friendly: CTE 대신 단일 쿼리 구조(또는 서브쿼리)를 사용하여 DB 엔진이 가장 효율적인 조인 순서를 결정하도록 함 


MYSQL
```sql
SELECT
  a.id,
  a.name,
  filtered_records.medals
FROM
  (
    -- 1. 무거운 이름(name) 없이 ID만으로 집계 (가볍고 빠름)
    SELECT
      r.athlete_id,
      GROUP_CONCAT(r.medal SEPARATOR ', ') AS medals
    FROM
      records r
      JOIN games g ON r.game_id = g.id
      JOIN teams t ON r.team_id = t.id
      JOIN events e ON r.event_id = e.id
    WHERE
      r.medal IS NOT NULL          -- 조기 필터링
      AND g.year <= 2016
      AND t.team = 'KOR'
      AND e.event = 'Volleyball Women''s Volleyball'
    GROUP BY
      r.athlete_id                 -- 정수형 ID로만 그룹화 (매우 빠름)
  ) AS filtered_records
  -- 2. 집계가 끝난 결과(적은 행)에 대해서만 이름을 조인
  JOIN athletes a ON filtered_records.athlete_id = a.id;
```
- Space Efficiency: 무거운 문자열 컬럼(name)을 그룹화 연산에서 제외하여 메모리 사용량을 최소화


### 기록

- 하나의 컬럼 특성이 다른 컬럼에서 여러 특성을 가질 경우, 그걸 하나로 표현하기 위해 GROUP_CONCAT() 사용
GROUP_CONCAT(medal SEPARATOR ', ') 
GROUP BY 
그룹화한 컬럼 기준으로 medal값이 여러개이면 ', '를 통해 내부 값을 연결 

- 이번 문제는 굳이 WITH 사용하지 않아도 괜찮았음. 