---
title: "[DB] SQL 실행 순서와 옵티마이저"
date: 2025-12-11 11:29:00 +0900
categories: [Database]
tags: [DB, DataOps, 면접질문, Transaction]
permalink: /20251211_cs/  
---

# 💡 한 줄 요약
> **"트랜잭션은 'All or Nothing'입니다. 작업 세트가 모두 성공해야 저장(Commit)되고, 하나라도 실패하면 없던 일로 되돌려야(Rollback) 데이터의 무결성이 지켜집니다."**

---

## 1. 🗣️ 면접 리와인드

**Q1. SQL 쿼리문의 논리적인 실행 순서는 어떻게 되는가?**
**A.** SQL이 작성된 순서(SELECT -> FROM)와 달리, 데이터베이스 내부에서는 데이터를 가져오고 필터링하는 순서대로 실행됨.
표준적인 실행 순서는 **FROM & JOIN (테이블 가져오기) → ON (조인 조건) → WHERE (행 필터링) → GROUP BY (그룹화) → HAVING (그룹 필터링) → SELECT (컬럼 선택) → ORDER BY (정렬) → LIMIT (개수 제한)** 임.
특히 **WHERE 절**이 GROUP BY보다 먼저 실행되므로, 그룹핑하기 전에 불필요한 데이터를 미리 걸러내는 것이 성능 최적화의 기본임.

**Q2. 옵티마이저(Optimizer)란 무엇인가?**
**A.** 사용자가 작성한 SQL 요구사항을 **가장 빠르고 효율적으로 수행할 수 있는 '최적의 실행 계획(Execution Plan)'을 수립해 주는 DBMS의 핵심 엔진**임.
같은 결과를 내는 쿼리라도 인덱스를 탈지, 풀 스캔을 할지, 조인 순서를 어떻게 할지에 따라 성능 차이가 큼. 옵티마이저는 통계 정보(데이터 분포, 레코드 수 등)를 바탕으로 각 경로의 비용(Cost)을 계산하여 최적의 경로를 선택해 줌.

**Q3. 대용량 데이터 파이프라인 환경에서는 'Slow Query'보다 'Throughput'이 더 중요하다고 했는데, 그 이유는 무엇인가?**
**A.** 서비스용 DB(OLTP)는 사용자 경험을 위해 개별 쿼리의 빠른 응답 속도(Latency)가 중요함. 반면, 데이터 웨어하우스(OLAP)나 배치 파이프라인 환경에서는 **'단위 시간당 얼마나 많은 데이터를 처리할 수 있는가(Throughput)'**가 핵심 지표이기 때문임.
따라서 개별 쿼리의 속도를 0.1초 줄이는 것보다, 시스템 전체 자원(CPU, Memory, I/O)을 효율적으로 분배하여 **대용량 데이터(TB 단위)를 병목 없이 안정적으로 처리하는 구조**를 만드는 것이 Data Ops의 핵심 역량임.

<br>

---

## 2. 🧠 핵심 개념 (Deep Dive)

### ① 옵티마이저(Optimizer)의 정의와 역할
* **정의 (DB의 내비게이션):** 사용자가 SQL을 통해 "무엇(What)"을 요구하면, "어떻게(How)" 데이터를 가져오는 것이 가장 효율적인지 경로를 결정해 주는 DBMS의 핵심 엔진.
* **역할:** 우리가 SQL로 `SELECT * FROM ...`이라고 목적지만 입력하면, 옵티마이저는 인덱스 유무, 데이터 양, 시스템 부하 등을 고려해 최적의 **실행 계획(Execution Plan)**을 수립함.
* **사용 예시:**
    * `WHERE 제목 = '해리포터'`라는 쿼리가 있을 때, 옵티마이저는 두 가지를 고민함.
    * **Plan A (Full Table Scan):** 도서관 1층부터 5층까지 모든 책장을 다 뒤진다. (데이터가 적을 때 유리)
    * **Plan B (Index Scan):** 도서 검색대(인덱스)에서 위치를 찾은 뒤 바로 이동한다. (데이터가 많을 때 유리)
    * 옵티마이저는 현재 데이터 상황을 보고 A와 B 중 더 저렴한 비용의 경로를 선택함.

### ② 옵티마이저의 내부 로직과 종류
옵티마이저는 쿼리를 실행하기 위해 다음 단계를 거쳐 비용(Cost)을 계산함.
1.  **파싱(Parsing):** SQL 문법 검사 및 쿼리 쪼개기.
2.  **통계 정보 확인:** 테이블의 데이터 건수, 컬럼의 분포도(Cardinality), 인덱스 상태 등의 장부를 확인.
3.  **경로 후보 생성:** 인덱스를 탈지 말지, 조인 순서를 어떻게 할지 여러 시나리오 생성.
4.  **비용 계산 및 선택:** 각 시나리오의 예상 소모 자원(I/O, CPU)을 계산하여 가장 저렴한 경로 선택.

* **RBO (Rule-Based Optimizer):** 규칙 기반. "인덱스가 있으면 무조건 탄다"처럼 데이터 상태와 무관하게 정해진 규칙(우선순위)만 따름. 유연성이 떨어져 현대에는 잘 안 씀.
* **CBO (Cost-Based Optimizer):** 비용 기반. 통계 정보를 바탕으로 "인덱스를 타는 게 그냥 읽는 것보다 비용이 적게 드나?"를 계산해서 판단함. 현대 DB의 표준 방식.

### ③ 조인 수행 방식 (Join Method)
테이블 A와 B를 합칠 때 옵티마이저가 선택하는 알고리즘 3대장.
* **Nested Loop Join (중첩 루프 조인):** 프로그래밍의 이중 `for`문과 동일함. A 테이블 한 줄 읽고, B 테이블 전체를 뒤져서 매칭. 소량의 데이터(OLTP) 처리에 유리하지만 대용량 데이터에서는 치명적으로 느림.
* **Sort Merge Join (정렬 병합 조인):** 양쪽 테이블을 조인 키 기준으로 각각 정렬(Sort)한 뒤, 지퍼를 잠그듯 위에서부터 맞춤. 범위 검색이나 부등호 연산에 유리함.
* **Hash Join (해시 조인):** 작은 테이블을 메모리에 올려 **해시 맵(Hash Map)**을 만들고, 큰 테이블을 읽으며 해시 함수로 매칭. 정렬 부하가 없고 대용량 데이터(OLAP) 처리에 가장 강력한 성능을 냄.

### ④ 시스템 환경과 성능 지표
* **서비스용 DB (OLTP):** '편의점 계산대'. 짧고 빠른 거래(Transaction)가 빈번함. 개별 쿼리의 응답 속도(Latency)가 중요하며, **Slow Query**를 없애는 것이 핵심 목표.
* **데이터 웨어하우스 (OLAP):** '본사 전략기획실'. 데이터를 모아 분석하고 통계를 냄. 복잡하고 무거운 쿼리가 실행됨. 응답 속도보다는 대용량 처리 능력이 중요.
* **Slow Query vs Throughput:**
    * **Slow Query (Latency):** 쿼리 하나가 완료되는 데 걸리는 시간. (사용자 경험에 중요)
    * **Throughput (처리량):** 단위 시간당 처리할 수 있는 데이터의 총량. (예: 1시간에 1TB 처리). Data Ops 환경에서는 덤프트럭처럼 한 번에 많이 처리하는 Throughput이 더 중요한 지표임.
* **배치 파이프라인 (Batch Pipeline):** '야간 택배 상하차'. 서비스 운영에 방해되지 않도록(주로 새벽), 데이터를 주기적으로(일괄적으로) 추출하여 분석용 DB로 옮기는 자동화된 프로세스 상태.

### ⑤ Data Ops 관점에서의 옵티마이저 확장
대용량 데이터를 다루는 엔지니어가 반드시 신경 써야 할 4가지 최적화 포인트.

**1. 통계 정보 (Statistics) 관리: "내비게이션 업데이트"**
* **개념:** CBO는 통계 정보를 믿고 경로를 짬. 그런데 대량의 데이터 적재(ETL) 후 통계 정보가 갱신되지 않으면, 옵티마이저는 데이터가 적은 줄 알고 잘못된 실행 계획(예: Loop Join)을 짤 수 있음.
* **Action:** 대용량 작업 후에는 반드시 통계 정보를 최신화해줘야 함.
```sql
-- PostgreSQL 예시: 테이블 통계 정보 갱신
ANALYZE TABLE my_big_table;
```

**2. 힌트 (Hint) 사용: "수동 경로 조작"**
* **개념:** 옵티마이저가 가끔 데이터 특성을 파악하지 못하고 비효율적인 선택을 할 때, 엔지니어가 강제로 특정 인덱스나 조인 방식을 쓰라고 명령하는 것. 튜닝의 최후 수단.
* **Action:** SQL 내에 주석 구문을 활용하여 강제 명령(예: 특정 인덱스를 사용해라, 해시 조인으로 처리해라 등)을 전달함.

```sql
-- MySQL/Oracle 예시: 강제로 해시 조인 사용 및 특정 인덱스 사용 유도
SELECT /*+ USE_HASH(A B) INDEX(A idx_date) */ *
FROM table_A A, table_B B
WHERE A.id = B.id;
```

**3. 파티션 프루닝 (Partition Pruning): "필요한 폴더만 열기"**
* **개념:** 10년 치 데이터가 있는 테이블에서 "오늘" 데이터만 조회할 때, 전체를 뒤지지 않고 "2025년 12월" 파티션(폴더)만 열어서 읽게 만드는 기술.
* **Action:** 테이블 설계 시 날짜 컬럼 등을 기준으로 파티셔닝(Partitioning)을 적용하여 I/O 비용을 획기적으로 줄임.

**4. 스필 (Spill to Disk): "책상 부족 현상"**
* **개념:** Hash Join이나 Sort 작업은 메모리(책상) 공간을 씀. 그런데 데이터가 너무 커서 할당된 메모리(`work_mem` 등)를 초과하면, 어쩔 수 없이 느린 **디스크(Temp 영역)**를 빌려 씀. 이를 스필(Spill)이라 함.
* **Action:** 쿼리 실행 계획에서 "Disk 사용"이 잡히면 쿼리 속도가 급락하므로, 메모리 설정을 늘리거나 쿼리를 쪼개서 메모리 내에서 처리되도록 유도해야 함.

<br>

---

## 3. 💬 내가 질문했던 개념 

### Q1. EXPLAIN(실행 계획)을 실행했을 때 나오는 컬럼들의 의미는?
**A.** `EXPLAIN` 결과는 쿼리의 **성적표이자 건강검진표**임. 각 컬럼은 옵티마이저가 어떤 판단을 내렸는지를 보여줌.

* **`id` (작업 순서):** `SELECT`문의 식별자. 쿼리 내에서 실행되는 순서를 나타냄. 조인이나 서브쿼리가 복잡할수록 번호가 늘어남.
* **`select_type` (쿼리 유형):** 쿼리의 복잡도를 나타냄. `SIMPLE`(단순 쿼리)이 가장 좋으며, `SUBQUERY`(서브쿼리), `DERIVED`(FROM절 서브쿼리) 등이 있음.
* **`table` (대상 테이블):** 해당 단계에서 참조하고 있는 테이블명. `<derived2>`처럼 임시 테이블이 표시되기도 함.
* **`type` (접근 방식) ⭐:** **성능의 핵심 지표.** 옵티마이저가 데이터를 "어떻게 찾으러 갔는지"를 보여줌.
    * `const`, `system`: PK 등으로 딱 1건만 찾음 (최고).
    * `ref`: 인덱스를 탔으나 결과가 여러 개일 수 있음 (양호).
    * `range`: 인덱스를 타고 범위 검색(`BETWEEN`, `>`)을 함 (양호).
    * `index`: 인덱스를 타긴 했으나 **인덱스 전체를 스캔**함 (비효율).
    * `ALL`: **풀 테이블 스캔(Full Table Scan)**. 인덱스를 아예 안 타고 맨땅에 헤딩함 (데이터가 많을 경우 최악).
* **`possible_keys` (후보 인덱스):** 사용될 '가능성'이 있었던 인덱스 목록.
* **`key` (사용 인덱스):** 실제로 선택된 인덱스. **이 값이 `NULL`이면 인덱스를 타지 않았다는 뜻.**
* **`rows` (예상 행 수):** 옵티마이저가 읽어야 할 것으로 예측한 데이터의 개수. 이 숫자가 클수록 쿼리가 무거움.
* **`filtered` (필터링 비율):** 스토리지 엔진이 읽어온 데이터 중, 최종 조건에 부합해 남은 데이터의 비율(%). 100에 가까울수록 불필요한 데이터를 덜 읽었다는 뜻.
* **`Extra` (비고):** 추가적인 정보.
    * `Using index`: 실제 데이터 파일 접근 없이 인덱스만으로 처리함 (커버링 인덱스, 매우 빠름).
    * `Using temporary`: 그룹핑 등을 위해 임시 테이블을 생성함 (메모리 사용, 주의).
    * `Using filesort`: 인덱스를 못 타서 별도로 정렬 작업을 수행함 (CPU 사용, 주의).

### Q2. 대량 데이터(100만 건) 적재 후 통계 정보는 바로 생성되나요? 없으면 어떻게 되나요?
**A.** 자동 생성되지 않았을 확률이 높으며, 이 경우 옵티마이저가 **비효율적인 경로(Full Scan)**를 선택할 가능성이 매우 큼.

* **통계 정보의 갱신 시점:** 대부분의 DB는 'Auto-Analyze' 기능이 있지만 실시간이 아님. "데이터의 10% 이상이 변경되었을 때" 같은 트리거 조건이 있으며, 시스템 부하가 높으면 갱신을 뒤로 미루기도 함.
* **빈 깡통 현상:** 통계 정보가 갱신되기 전까지 옵티마이저는 이 테이블을 **"데이터가 거의 없는 빈 테이블"**로 착각함.
* **결과:** 100만 건이 들어있음에도 불구하고, 옵티마이저는 "데이터가 적으니 인덱스 펴는 비용보다 그냥 훑는 게 빠르겠다"고 판단하여 **Full Table Scan**을 감행함. 이로 인해 쿼리 성능이 급격히 저하됨.
* **해결책:** 대량 적재(Bulk Insert) 직후에는 반드시 **`ANALYZE TABLE`** 명령어를 수동으로 실행해 옵티마이저에게 데이터 현황을 알려줘야 함.

### Q3. 쿼리가 메모리를 얼마나 쓰는지 어떻게 모니터링하나요?
**A.** 쿼리 실행 후 나오는 **영수증(EXPLAIN ANALYZE)**을 확인하거나, 실시간 **CCTV(모니터링 뷰/툴)**를 통해 확인함.

* **방법 1. `EXPLAIN ANALYZE` (실행 후 분석):**
    * 단순 `EXPLAIN`은 예측값이고, `ANALYZE`를 붙이면 실제 쿼리를 돌려보고 결과를 보여줌.
    * 결과 로그에서 `Memory: 25kB` 처럼 메모리 내에서 처리되었는지, **`Disk: 5000kB` (External merge)** 처럼 메모리가 부족해 디스크(Temp)까지 빌려 썼는지를 확인해야 함. 디스크를 썼다면 메모리 설정을 늘리거나 쿼리 튜닝이 필요함.
* **방법 2. 시스템 뷰 & 모니터링 툴 (실시간 감시):**
    * **DB 내부 뷰:** MySQL의 `sys` 스키마 등을 조회하여 현재 메모리 점유율이 높은 쿼리를 역추적함.
    * **외부 툴:** Datadog, Prometheus 같은 모니터링 툴을 연동하여, 특정 시간대에 메모리 사용량이 치솟는 스파이크(Spike)를 감지하고 범인 쿼리를 찾아냄.

<br>

---

## 4. 🗑️ 내일의 질문 (호기심 메모장)
