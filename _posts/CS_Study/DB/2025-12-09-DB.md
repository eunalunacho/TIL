---
title: "[DB] Index vs Primary Key와 성능 최적화"
date: 2025-12-09 23:45:00 +0900
categories: [Database]
tags: [DB, DataOps, 면접질문, Index]
permalink: /20251209_cs/  
---

# 💡 한 줄 요약
> **"Primary Key는 데이터를 식별하는 '신분증'이고, Index는 검색을 돕는 '목차'입니다.       인덱스는 조회 속도를 높여주지만, 물리적 정렬 비용 때문에 저장(쓰기) 속도는 저하시킬 수 있습니다."**

---

## 1. 🗣️ 면접 리와인드

**Q1. 인덱스(Index)가 무엇인가요?**
인덱스는 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조임. 책 뒤에 있는 **'색인(Index)'**과 같은 역할을 함. 데이터의 위치(Pointer)를 별도로 저장하고 정렬해 두어서, 데이터를 찾을 때 전체를 다 뒤지는 **풀 테이블 스캔(Full Table Scan)**을 하지 않고도 빠르게 조회할 수 있게 도와줌.

**Q2. Primary Key(PK)와 인덱스의 차이가 뭘까요?**
Primary Key는 데이터를 식별하기 위한 **'논리적인 제약 조건(Constraint)'**임. 중복될 수 없고 NULL 값을 가질 수 없어 각 행(Row)을 유일하게 구분하는 역할을 함.
반면 인덱스는 검색 성능을 높이기 위한 **'물리적인 도구'**임. 보통 PK를 생성하면 DBMS가 자동으로 이를 기반으로 인덱스(Clustered Index)를 만들어주지만, 개념적으로 PK는 '식별자'이고 인덱스는 '검색 도구'라는 차이가 있음.

**Q3. 특정한 로우를 찾아낼 때 쓰는 거는 뭘까요?**
데이터를 특정할 때는 Primary Key 값을 기준으로 쿼리(WHERE 절)를 날림. 하지만 내부적으로 그 로우를 **빠르게 찾아내는 메커니즘은 '인덱스'**임. 인덱스가 없다면 PK를 조건으로 주더라도 테이블 전체를 다 읽어야 할 수도 있기 때문임.


---


## 2. 🧠 핵심 개념 (Deep Dive)

### ① 인덱스의 정의와 Trade-off
* **정의:** 책의 색인(목차)처럼 데이터(책의 내용)와 레코드의 주소(페이지 번호)를 Key-Value 쌍으로 저장하여 검색 속도를 높이는 기능.
* **작동 원리:** DBMS는 인덱스를 항상 **정렬된 상태**로 유지함. 따라서 탐색(SELECT) 속도는 빠르지만, 데이터 변경(INSERT, UPDATE, DELETE) 시 인덱스도 함께 수정/정렬해야 하므로 저장 성능은 저하됨.
* **결론:** 읽기 속도를 높이기 위해 저장 성능을 희생하는 기능임. 무분별한 인덱스 생성은 저장 성능 저하 및 인덱스 비대화를 초래하여 역효과를 낼 수 있음.

### ② 인덱스 자료구조 (B+-Tree vs Hash)
* **B+-Tree 알고리즘:**
    * 가장 일반적으로 사용되는 인덱스 알고리즘.
    * 칼럼의 원래 값을 이용해(주로 앞부분만 잘라서) 인덱싱함.
    * **사용 이유:** Hash는 등호(`=`) 연산에만 특화되어 있어, 부등호(`<>`, 범위 검색) 연산이 잦은 데이터베이스 환경에서는 순서가 보장되는 B-Tree 계열이 더 적합함.
* **Hash 인덱스 알고리즘:**
    * 칼럼 값을 해시값으로 변환하여 인덱싱.
    * 매우 빠른 검색(O(1))을 지원하지만, 값을 변형하므로 **범위 검색**이나 **전방 일치 검색**이 불가능함.
    * 주로 메모리 기반 DB에서 사용됨.

### ③ 인덱스의 종류
* **Primary vs Secondary:**
    * **Primary Index:** PK에 대해 생성되는 인덱스. 테이블당 1개만 존재.
    * **Secondary Index:** PK가 아닌 다른 칼럼에 생성되는 인덱스. 테이블당 여러 개 생성 가능.
* **Clustered vs Non-Clustered:**
    * **Clustered Index:** 인덱스 키 순서대로 **실제 데이터가 물리적으로 정렬**되어 저장됨. 테이블당 1개만 존재(주로 PK). 물리적으로 인접한 데이터를 묶어서 저장하므로 조회 속도가 매우 빠름.
    * **Non-Clustered Index:** 데이터는 그대로 두고, 별도의 인덱스 테이블에 **키와 데이터 위치(Pointer)**만 정렬해둠. 테이블당 여러 개 생성 가능.
* **Composite Index (복합 인덱스):**
    * 두 개 이상의 컬럼을 합쳐서 인덱스를 생성함. **필드의 순서**가 매우 중요함. (예: A, B 순서로 만들었을 때 A 없이 B만으로는 인덱스 효과를 못 봄)

### ④ 인덱스 성능 고려사항 (Cardinality)
* **DML 성능 저하:**
    * `INSERT`: 인덱스에도 데이터 추가 및 정렬 비용 발생.
    * `DELETE`: 인덱스에서 데이터를 지우지 않고 '사용 안 함' 표시만 남김 → 인덱스 비대화 유발.
    * `UPDATE`: 기존 값 삭제(마킹) + 신규 값 삽입 작업이 동시에 발생.
* **카디널리티(Cardinality)와 효율:**
    * 데이터의 형식(분포도)에 따라 효율이 달라짐.
    * 중복도가 낮고 유일한 값이 많은(Cardinality가 높은) 컬럼에 인덱스를 걸어야 효율적임.
    * 반대로 중복도가 높은(예: 남/여, T/F) 컬럼은 인덱스를 거쳐 다시 디스크 I/O를 하는 비용이 더 커서 비효율적일 수 있음.

### ⑤ Data Ops 관점에서의 Transaction
* **Fragmentaion (단편화) 관리:** 잦은 `UPDATE/DELETE`로 인해 인덱스 페이지에 빈 공간이 많아지면(단편화), 같은 데이터를 읽어도 더 많은 페이지를 읽어야 해서 성능이 저하됨. 주기적인 **Rebuild**나 **Reorganize** 작업이 필요함.
* **Bulk Insert 최적화:** 대량의 데이터를 적재할 때 인덱스가 켜져 있으면 정렬 비용 때문에 속도가 매우 느림. Ops 환경에서는 **인덱스를 잠시 끄고(Disable) 적재 후 다시 켜는(Rebuild)** 전략을 사용하기도 함. 주로 Non-Clustered Index를 끔. Clustered Index를 끄기도 함. 
* **모니터링:** `Slow Query Log`를 분석하여 인덱스를 타지 않는(Full Scan) 쿼리를 찾아내고, `EXPLAIN` 명령어로 실행 계획을 분석하는 습관이 필요함.

---

## 3. 💬 내가 질문했던 개념

### ① 시각적 차이: Pandas vs DB
* **Pandas DataFrame:** 인덱스가 데이터 바로 왼쪽 굵은 글씨로 **눈에 보임**. (행을 지칭하는 역할)
* **Database:** `SELECT` 결과에는 인덱스가 **보이지 않음**. DB 내부의 별도 공간에 '정렬된 비밀 노트(자료구조)' 형태로 숨겨져 있음.

### ② 사용자의 제어권
* **자동 생성:** PK나 Unique 제약 조건을 걸면 DBMS가 무결성 보장을 위해 강제로 생성함.
* **수동 생성:** 검색 성능(WHERE절) 최적화를 위한 일반 인덱스는 사용자가 직접 `CREATE INDEX`로 생성하고 `DROP`으로 관리해야 함.

```sql
-- 인덱스 생성 예시
CREATE INDEX idx_user_name ON users (name);

-- 인덱스 삭제 예시
DROP INDEX idx_user_name ON users;
```

### ③ 인덱스와 성능 (Trade-off) 
**Q. 인덱스를 많이 만들면 왜 데이터 저장(쓰기) 성능이 떨어지는가?**
* **인덱스 테이블 갱신 비용:** 새로운 데이터가 추가될 때마다 관련된 모든 인덱스(B-Tree)에도 키 값과 포인터를 추가하고 다시 정렬해야 함.
* **데이터 테이블 재정렬 비용 (Clustered Index):** PK(Clustered Index)가 설정된 경우, 데이터 자체가 물리적 순서에 맞춰 저장되어야 함. 중간에 데이터가 끼어들면 기존 데이터를 뒤로 밀어내거나 페이지를 쪼개는(Page Split) 작업이 발생해 쓰기 성능이 크게 저하됨.

**Q. 그렇다면 쓰기 성능을 위해 어떤 PK를 쓰는 게 효율적인가?**
* **순차적으로 증가하는 숫자(Auto Increment)**를 PK로 사용하는 것이 효율적임.
* 값이 순서대로 들어오면 데이터를 중간에 끼워 넣을 필요 없이 **마지막 페이지에 이어서 쓰기(Append-only)**만 하면 되기 때문. 이는 페이지 분할(Page Split)과 단편화를 최소화하여 쓰기 성능을 최적화함. 분산 환경에서는 비효율적일 수 있음

---

## 4. 🗑️ 내일의 질문 (호기심 메모장)
- 분산 DB 환경에서 Auto Increment PK(순차 키)를 쓸 때 발생하는 Hotspot 문제와 해결 방법 (Snowflake ID 등)
- UUID(Random Key)가 분산 환경에서 가지는 장점(쓰기 분산)과 단점(페이지 분할) 비교
- 일반 RDBMS(단일 서버) vs 분산 DB 환경에서의 인덱스 전략 차이