---
title: "[DB] Index vs Primary Key와 성능 최적화"
date: 2024-12-09 23:45:00 +0900
category: [Database]
tags: [DB, DataOps, 면접질문, Performance]
permalink: /20251209_cs/  
---

# 💡 한 줄 요약
> **"Primary Key는 데이터를 식별하는 '신분증'이고, Index는 검색을 돕는 '목차'입니다. 인덱스는 조회 속도를 높여주지만, 물리적 정렬 비용 때문에 저장(쓰기) 속도는 저하시킬 수 있습니다."**

---

## 1. 🗣️ 면접 대비 Q&A (핵심 질문)

<details>
<summary><strong>Q1. Index와 Primary Key의 차이는 무엇인가요?</strong></summary>
<div markdown="1">

**A.** 가장 큰 차이는 **'목적'**과 **'물리적 저장 방식'**입니다.
* **Primary Key (PK):** 데이터를 유일하게 식별하기 위한 **논리적 제약 조건(Constraint)**입니다. (중복 불가, NULL 불가)
* **Index:** 검색 속도를 향상시키기 위한 **물리적 자료구조**입니다.
보통 PK를 설정하면 DBMS는 이를 기준으로 데이터를 물리적으로 정렬하는 **Clustered Index**를 자동으로 생성하지만, 개념적으로 PK는 식별자이고 인덱스는 검색 도구라는 차이가 있습니다.

</div>
</details>

<br>

<details>
<summary><strong>Q2. 인덱스를 많이 만들면 왜 데이터 저장(쓰기) 성능이 떨어지나요?</strong></summary>
<div markdown="1">

**A.** 두 가지 비용이 발생하기 때문입니다.
1. **인덱스 테이블 갱신 비용:** 새로운 데이터가 추가될 때마다 관련된 모든 인덱스(B-Tree)에도 키 값과 포인터를 추가하고 다시 정렬해야 합니다.
2. **데이터 테이블 재정렬 비용 (Clustered Index):** PK(Clustered Index)가 설정된 경우, 데이터 자체가 물리적 순서에 맞춰 저장되어야 합니다. 중간에 데이터가 끼어들면 기존 데이터를 뒤로 밀어내거나 페이지를 쪼개는(Page Split) 작업이 발생해 쓰기 성능이 크게 저하됩니다.

</div>
</details>

<br>

<details>
<summary><strong>Q3. 그렇다면 쓰기 성능을 위해 어떤 PK를 쓰는 게 효율적인가요?</strong></summary>
<div markdown="1">

**A.** **순차적으로 증가하는 숫자(Auto Increment)**를 PK로 사용하는 것이 효율적입니다.
값이 순서대로 들어오면 데이터를 중간에 끼워 넣을 필요 없이 **마지막 페이지에 이어서 쓰기(Append-only)**만 하면 되기 때문입니다. 이는 페이지 분할(Page Split)과 단편화를 최소화하여 쓰기 성능을 최적화합니다.

</div>
</details>

---

## 2. 🧠 내가 질문했던 개념 정리 (Deep Dive)

### ① 시각적 차이: Pandas vs DB
* **Pandas DataFrame:** 인덱스가 데이터 바로 왼쪽 굵은 글씨로 **눈에 보임**. (행을 지칭하는 역할)
* **Database:** `SELECT` 결과에는 인덱스가 **보이지 않음**. DB 내부의 별도 공간에 '정렬된 비밀 노트(자료구조)' 형태로 숨겨져 있음.

### ② Clustered Index (군집 인덱스)
* **정의:** 인덱스의 정렬 순서대로 **실제 데이터(Row)가 물리적으로 저장**되는 방식.
* **특징:** 테이블당 **단 1개**만 존재 가능 (물리적 정렬 순서는 하나니까). 주로 **PK**가 이 역할을 담당함.
* **Unique Constraint는?**: 기본적으로는 **Non-Clustered Index**임. (단, PK가 없는 예외적인 경우엔 Clustered가 될 수도 있음)

### ③ 사용자의 제어권
* **자동 생성:** PK나 Unique 제약 조건을 걸면 DBMS가 무결성 보장을 위해 강제로 생성.
* **수동 생성:** 검색 성능(WHERE절) 최적화를 위한 일반 인덱스는 사용자가 직접 `CREATE INDEX`로 생성하고 `DROP`으로 관리해야 함.

---

## 3. 🗑️ 내일의 질문 (호기심 메모장)
- [ ] (오늘 질문하려다 뺀 것들) 분산 환경에서의 Sharding과 Hotspot 문제란?