---
title: "[DB] 트랜잭션(Transaction)과 ACID"
date: 2025-12-10 20:34:00 +0900
categories: [Database]
tags: [DB, DataOps, 면접질문, Transaction]
permalink: /20251210_cs/  
---

# 💡 한 줄 요약
> **"트랜잭션은 'All or Nothing'입니다. 작업 세트가 모두 성공해야 저장(Commit)되고, 하나라도 실패하면 없던 일로 되돌려야(Rollback) 데이터의 무결성이 지켜집니다."**

---

## 1. 🗣️ 면접 리와인드

**Q1. 트랜잭션(Transaction)이란 무엇이며, Commit과 Rollback의 차이는 무엇인가요?**
**A.** 트랜잭션은 데이터베이스의 상태를 변화시키는 하나의 **논리적인 작업 단위**입니다.
예를 들어 '계좌 이체'는 [출금]과 [입금]이라는 두 과정이 합쳐져야 하나의 의미를 가집니다.
* **Commit:** 트랜잭션 내의 모든 작업이 성공적으로 수행되었음을 확정하고, **DB에 영구적으로 반영**하는 명령어입니다. (Save)
* **Rollback:** 작업 중 문제가 발생했을 때, 트랜잭션 내의 모든 변경 사항을 취소하고 **작업 시작 전의 상태로 되돌리는** 명령어입니다. (Undo)

**Q2. 트랜잭션 내에서 여러 작업(A, B, C)을 하다가 중간에 에러가 나면, 앞서 실행된 작업은 어떻게 되나요?**
**A.** **원자성(Atomicity)** 원칙에 의해 앞서 실행된 작업들도 모두 취소됩니다.
트랜잭션은 **'전부 실행되거나, 아예 실행되지 않거나(All or Nothing)'** 둘 중 하나여야 하기 때문에, 중간에 실패하면 **전체 롤백(Rollback)**이 발생하여 데이터 일관성을 유지합니다.

**Q3. 트랜잭션은 쪼개질 수 있나요? 일부만 롤백되는 경우도 있나요?**
**A.** 기본적으로 트랜잭션은 쪼개질 수 없는 **원자적 단위**입니다. 따라서 원칙적으로는 일부만 롤백될 수 없습니다.
다만, **Savepoint(세이브포인트)** 기능을 사용하면 트랜잭션 내부에 특정 지점을 지정하여, 에러 발생 시 그 지점까지만 부분적으로 롤백하는 것은 기술적으로 가능합니다.


---


## 2. 🧠 핵심 개념 (Deep Dive)

### ① 트랜잭션의 정의와 Lock과의 차이
* **트랜잭션 (Transaction):** 데이터의 **정합성(Integrity)**을 보장하기 위한 기능. 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게(All or Nothing) 만들어주는 기능.
* **잠금 (Lock):** **동시성(Concurrency)**을 제어하기 위한 기능. 여러 곳에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할.
    * *비유:* 트랜잭션은 '작업의 완전성'을 지키는 규칙이고, 락은 '줄 세우기'를 위한 자물쇠임.

### ② 트랜잭션의 특성: ACID
데이터베이스가 '믿을 수 있는 저장소'가 되기 위해 반드시 지켜야 할 4가지 성질.

1.  **Atomicity (원자성):** "All or Nothing". 트랜잭션 중간에 문제가 생기면 어떠한 작업 내용도 수행되어서는 안 되며, 아무런 문제가 없을 때만 모든 작업이 수행되어야 함.
2.  **Consistency (일관성):** 트랜잭션이 완료된 다음의 상태에서도 트랜잭션 전과 동일하게 데이터의 일관성(규칙 준수)을 보장해야 함. (예: 잔액은 마이너스가 될 수 없다)
3.  **Isolation (고립성/격리성):** 각각의 트랜잭션은 서로 간섭 없이 독립적으로 수행되어야 함. (격리 수준에 따라 강도가 다름)
4.  **Durability (지속성):** 트랜잭션이 정상적으로 종료(Commit)된 다음에는 시스템 고장 등과 관계없이 영구적으로 결과가 저장되어야 함.

### ③ 트랜잭션의 상태 (Lifecycle)

* **Active:** 트랜잭션이 시작되어 실행 중이며 동작 중인 상태.
* **Partially Committed:** `Commit` 명령(요청)이 도착한 상태. SQL문은 수행되었고 커밋 직전인 상태.
* **Failed:** 트랜잭션 실패 상태. 더 이상 정상적으로 진행할 수 없는 상태.
* **Aborted:** 트랜잭션 취소 상태. 실행 이전 데이터로 돌아간(Rollback) 상태.
* **Committed:** 트랜잭션 완료 상태. 정상적으로 완료되어 DB에 반영된 상태.

### ④ Data Ops 관점에서의 트랜잭션
* **데드락 (Deadlock):** 트랜잭션 A와 B가 서로 상대방이 잡고 있는 자원(Lock)이 풀리기만을 무한히 기다리는 상태. Ops는 모니터링을 통해 이를 감지하고 해결해야 함. 오래된 트랜잭션을 강제로 끊어주거나, 애초에 락을 짧게 걸도록 쿼리를 튜닝 
* **대용량 처리 (Batch):** 100만 건을 한 번에 커밋하면 롤백 비용이 너무 크므로, 적절한 단위(Batch Size)로 쪼개서 커밋해야 함. 트랜잭션의 범위를 작게 쪼개야 실패했을 때 리스크도 적고, DB에 부하도 덜 줌 
* **멱등성 (Idempotency):** 파이프라인 재실행 시 데이터 중복이 발생하지 않도록 `Upsert` 등을 활용해 트랜잭션을 설계해야 함. (이미 있으면 업데이트하고, 없으면 넣어라(Upsert))

### ⑤ 사용할 때 주의할 점 (범위 최소화)
트랜잭션의 범위는 **'꼭 필요한 최소의 코드'**에만 적용해야 함.
* **이유:** 데이터베이스 커넥션은 개수가 제한적이기 때문.
* **설명:** 트랜잭션을 시작하면 커넥션(Connection)을 하나 점유하게 되는데, 이 상태에서 DB 작업과 무관한 긴 작업(외부 통신, 복잡한 연산 등)을 수행하면 그만큼 커넥션을 낭비하게 됨. 이는 사용 가능한 여유 커넥션 개수를 줄여, 다른 프로그램이 커넥션을 얻기 위해 기다려야 하는 병목 현상을 유발할 수 있음.

---

## 3. 💬 내가 질문했던 개념 

### Q1. "DB 커넥션 개수가 제한적"이라는 게 무슨 뜻?
**A.** 데이터베이스 커넥션(Connection)은 단순히 논리적인 연결이 아니라, **DB 서버의 물리적 자원인 메모리(RAM)를 점유하는 실제 통로(전선)**이기 때문임.
* **물리적 의미:** 커넥션 하나가 생성될 때마다 서버의 메모리를 일정량 사용함.
* **설정값 (max_connections):** 서버의 물리적 한계(RAM, CPU) 때문에 DB 관리자는 동시에 연결할 수 있는 최대 커넥션 수(`max_connections`)를 제한해둠.
* **결론:** 따라서 트랜잭션 내에서 불필요하게 커넥션을 오래 붙잡고 있으면(범위가 넓으면), 한정된 자원인 커넥션 풀(Pool)이 고갈되어 서비스 장애로 이어질 수 있음.

### Q2. Savepoint란?
**A.** 트랜잭션의 'All or Nothing' 원칙에서 예외적으로 **부분 롤백(Partial Rollback)**을 가능하게 해주는 기능.
* 트랜잭션 중간에 `SAVEPOINT`를 지정해두면, 이후 에러가 발생했을 때 전체를 롤백하지 않고 해당 지점까지만 되돌릴 수 있음.
* 대용량 데이터 처리 시, 999번째 데이터 오류 때문에 앞선 998개를 모두 취소하는 비효율을 막기 위해 사용될 수 있음.

---

## 4. 🗑️ 내일의 질문 (호기심 메모장)
